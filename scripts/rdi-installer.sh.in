#!/bin/bash

# SPDX-License-Identifier: MIT

set -e
set -o pipefail

COLOR_GREEN=2
COLOR_GRAY=250
COLOR_RED=9
COLOR_BLUE=21
COLOR_DARKBLUE=4

COLOR_BACKGROUND=$COLOR_DARKBLUE
COLOR_FOREGROUND=$COLOR_GREEN
COLOR_LIGHT_FOREGROUND=10
COLOR_ITEM=$COLOR_GRAY
COLOR_TITLE=$COLOR_BLUE
COLOR_TEXT=$COLOR_BLUE
COLOR_WARNING=$COLOR_RED

CURSOR="‣" # "→"

VERSION=@VERSION@

TEMP_DIR=$(mktemp -d)

cleanup()
{
    local exit_code=$?

    if [ -d "${TEMP_DIR}/mount" ]; then
        mountpoint -q "${TEMP_DIR}/mount" && umount -R -f "${TEMP_DIR}/mount" || echo "WARNING: Failed to unmount ${TEMP_DIR}/mount"
    fi

    if [[ -d "$TEMP_DIR" ]]; then
        rm -rf "$TEMP_DIR"
    fi

    exit $exit_code
}

trap cleanup EXIT

if [ -z "$RDII_DEBUG" ]; then
    KEYWAIT=keywait
    RDII_HELPER=rdii-helper

    # shellcheck source=../scripts/keymap.sh
    source @RDIIDIR@/keymap.sh
    # shellcheck source=../scripts/target_device.sh
    source @RDIIDIR@/target_device.sh
    # shellcheck source=../scripts/select_image.sh
    source @RDIIDIR@/select_image.sh
    # shellcheck source=../scripts/system_info.sh
    source @RDIIDIR@/system_info.sh
else
    KEYWAIT=./keywait
    RDII_HELPER=./rdii-helper

    source ../scripts/keymap.sh
    source ../scripts/target_device.sh
    source ../scripts/select_image.sh
    source ../scripts/system_info.sh
fi

clear_and_print_title()
{
    clear
    gum style \
	--align center \
	--width 80 \
	--background "$COLOR_BACKGROUND" \
	--foreground "$COLOR_LIGHT_FOREGROUND" \
	"Raw Disk Image Installer ${VERSION}"
    echo ""
}

# Check for gum
if ! command -v gum &> /dev/null; then
    echo "Error: 'gum' is not installed."
    exit 1
fi

#
# Initialize some defaults
#
# Read current KEYMAP from /etc/vconsole.conf
DEFAULT_KEYMAP=""
VCONSOLE_FILE="/etc/vconsole.conf"
RDII_CONFIG_FILE="/run/rdi-installer/rdii-config"
TARGET_DEVICE=""
SOURCE_IMAGE=""
CONFIG_TARGET_DEVICE=""
CONFIG_SOURCE_IMAGE=""

# Configuration order:
# 1. /proc/cmdline
# 2. config file
# 3. built in defaults

# Parse rdii-config file
if [ -f "$RDII_CONFIG_FILE" ]; then
    CONFIG_TARGET_DEVICE=$(sed -n 's/.*rdii\.device=\([^ ]*\).*/\1/p' $RDII_CONFIG_FILE)
    CONFIG_SOURCE_IMAGE=$(sed -n 's/.*rdii\.url=\([^ ]*\).*/\1/p' $RDII_CONFIG_FILE)
    CONFIG_KEYMAP=$(sed -n 's/.*rdii\.keymap=\([^ ]*\).*/\1/p' $RDII_CONFIG_FILE)
fi
CMDLINE_TARGET_DEVICE=$(sed -n 's/.*rdii\.device=\([^ ]*\).*/\1/p' /proc/cmdline)
CMDLINE_SOURCE_IMAGE=$(sed -n 's/.*rdii\.url=\([^ ]*\).*/\1/p' /proc/cmdline)
CMDLINE_KEYMAP=$(sed -n 's/.*rdii\.keymap=\([^ ]*\).*/\1/p' /proc/cmdline)

if [ -n "$CMDLINE_SOURCE_IMAGE" ]; then
    SOURCE_IMAGE="$CMDLINE_SOURCE_IMAGE"
elif [ -n "$CONFIG_SOURCE_IMAGE" ]; then
    SOURCE_IMAGE="$CONFIG_SOURCE_IMAGE"
fi
if [ -n "$CMDLINE_TARGET_DEVICE" ]; then
    TARGET_DEVICE="$CMDLINE_TARGET_DEVICE"
elif [ -n "$CONFIG_TARGET_DEVICE" ]; then
    TARGET_DEVICE="$CONFIG_TARGET_DEVICE"
fi

if [ -f "$VCONSOLE_FILE" ]; then
    # sourcing in a subshell to avoid polluting current environment,
    # though straightforward sourcing is also fine.
    # shellcheck source=/dev/null
    DEFAULT_KEYMAP=$(source "$VCONSOLE_FILE" && echo "$KEYMAP")
fi
if [ -n "$CMDLINE_KEYMAP" ]; then
    DEFAULT_KEYMAP="$CMDLINE_KEYMAP"
elif [ -n "$CONFIG_KEYMAP" ]; then
    DEFAULT_KEYMAP="$CONFIG_KEYMAP"
fi

# set keymap (not in debug mode)
if [ -n "$DEFAULT_KEYMAP" ] && [ -z "$RDII_DEBUG" ]; then
    loadkeys "$DEFAULT_KEYMAP" ||:
fi

case $TERM in
    xterm-*)
	SPINNER="--spinner=globe"
	WARN_SIGN="⚠"
	;;
    *)
	SPINNER="--spinner=line --spinner.foreground=$COLOR_TEXT"
	WARN_SIGN="!!!"
	;;
esac

mkdir -p /run/rdi-installer

clear

# Splash screen at start

gum style \
    --border double \
    --align center \
    --width 70 \
    --margin "1 2" \
    --padding "2 4" \
    --border-background "$COLOR_BACKGROUND"\
    --border-foreground "$COLOR_LIGHT_FOREGROUND" \
    --background "$COLOR_BACKGROUND" \
    --foreground "$COLOR_LIGHT_FOREGROUND" \
    "Raw Disk Image Installer ${VERSION}"

# shellcheck disable=SC2086
gum spin $SPINNER --title.foreground="$COLOR_TITLE" --title="Press any key to continue or wait 5s..." -- $KEYWAIT -t ""

# We quit if user hits ESC, Ctrl-C or selects Install/Abort
while true; do
    clear_and_print_title

    SELECTED=$(gum choose \
		   --header="Configuration Settings" \
		   --header.foreground="$COLOR_TITLE" \
		   --cursor="${CURSOR} " \
		   --cursor.foreground="$COLOR_FOREGROUND" \
		   --item.foreground="$COLOR_ITEM" \
		   --selected.foreground="$COLOR_FOREGROUND" \
		   --limit=1 \
		   "Select Image ($SOURCE_IMAGE)" \
		   "Select Target Device ($TARGET_DEVICE)" \
		   "Select Keymap ($DEFAULT_KEYMAP)" \
		   "System Information" \
		   "Refresh" \
		   "Abort" \
		   "Start Installation"
	    )

    case "$SELECTED" in
	"Select Keymap"*)
	    set_keymap
	    ;;
	"Select Target Device"*)
	    select_target_device
	    ;;
	"Select Image"*)
	    select_image
	    ;;
	"System Information")
	    system_information
	    ;;
	"Refresh")
	    clear_and_print_title
	    ;;
	"Abort" | "")
	    gum style --foreground="$COLOR_TITLE" "Exiting..."
	    exit 3
	    ;;
	"Start Installation")
	    if [ -z "$SOURCE_IMAGE" ]; then
		gum style \
		    --foreground="$COLOR_WARNING" \
		    "You need to select a raw disk image first!"
		$KEYWAIT -t ""
		SELECTED="start"
	    fi
	    if [ -z "$TARGET_DEVICE" ]; then
		gum style \
		    --foreground="$COLOR_WARNING" \
		    "You need to select a target device first!"
		$KEYWAIT -t ""
		SELECTED="start"
	    fi
	    break
	    ;;
	*)
	    echo "Internal Error: '$SELECTED'"
	    exit 2
	    ;;
    esac
done

clear_and_print_title
gum style \
    --align="center" \
    --border=normal \
    --border-foreground="$COLOR_FOREGROUND" \
    --foreground="$COLOR_FOREGROUND" \
    "Source Image:" \
    "$SOURCE_IMAGE" \
    "Installation Target:" \
    "$TARGET_DEVICE"
echo ""
if gum confirm \
       --default \
       --prompt.foreground "$COLOR_WARNING" \
       --selected.background "$COLOR_WARNING" \
       --selected.foreground "$COLOR_FOREGROUND" \
       --unselected.background "$COLOR_BACKGROUND" \
       "WARNING: PERMANENT DATA LOSS - Are you absolutely sure?"; then
        gum style --foreground "$COLOR_TEXT" "Confirmed. Proceeding with writing $SOURCE_IMAGE to $TARGET_DEVICE..."
    else
        gum style --foreground "$COLOR_TEXT" "Aborted."
        $KEYWAIT -t "" -s 2
	exit 1
    fi

if [[ "$SOURCE_IMAGE" == *.gz ]]; then
    DECOMPRESSOR="pigz -dc"
    command -v pigz >/dev/null 2>&1 || { echo "Error: pigz not installed, install with: zypper in pigz"; exit 1; }
elif [[ "$SOURCE_IMAGE" == *.bz2 ]]; then
    DECOMPRESSOR="pbzip2 -dc"
    command -v pbzip2 >/dev/null 2>&1 || { echo "Error: pbzip2 not installed, install with: zypper in pbzip2"; exit 1; }
elif [[ "$SOURCE_IMAGE" == *.xz ]]; then
    DECOMPRESSOR="xz -dc -T0"
    command -v xz >/dev/null 2>&1 || { echo "Error: xz not installed, install with: zypper in pbzip2"; exit 1; }
else
    DECOMPRESSOR="cat"
fi

# Check for URLs (http, https, ftp)
if [[ "$SOURCE_IMAGE" =~ ^(https?|ftp):// ]]; then
    echo "URL Detected: $SOURCE_IMAGE" | gum style --foreground "$COLOR_TEXT"

    if ! curl -L -C - --fail --retry 5 --no-progress-meter "${SOURCE_IMAGE}.sha256" --output /run/rdi-installer/image.sha256; then
	if gum confirm \
               --default \
               --prompt.foreground "$COLOR_WARNING" \
               --selected.background "$COLOR_WARNING" \
               --selected.foreground "$COLOR_GRAY" \
               --unselected.background "$COLOR_BACKGROUND" \
               --unselected.foreground "$COLOR_GRAY" \
               "No sha256 checksum found, really continue without image verification?"; then
            gum style --foreground "$COLOR_TEXT" "Confirmed. Proceeding..."
	else
            gum style --foreground "$COLOR_TEXT" "Aborted."
            $KEYWAIT -t "" -s 2
	    exit 1;
	fi
    elif ! curl -L -C - --fail --retry 5 --no-progress-meter "${SOURCE_IMAGE}.sha256.asc" --output /run/rdi-installer/image.sha256.asc; then
	if gum confirm \
               --default \
               --prompt.foreground "$COLOR_WARNING" \
               --selected.background "$COLOR_WARNING" \
               --selected.foreground "$COLOR_GRAY" \
               --unselected.background "$COLOR_BACKGROUND" \
               --unselected.foreground "$COLOR_GRAY" \
               "No gpg signature found, really continue without verification?"; then
            gum style --foreground "$COLOR_TEXT" "Confirmed. Proceeding..."
	else
            gum style --foreground "$COLOR_TEXT" "Aborted."
            $KEYWAIT -t "" -s 2
	    exit 1;
	fi
    elif ! gpgv --keyring /etc/systemd/import-pubring.gpg /run/rdi-installer/image.sha256.asc /run/rdi-installer/image.sha256; then
	gum style --foreground="$COLOR_WARNING" "ERROR: GPG signature verification failed! Aborting..."
	$KEYWAIT -s 0
	exit 1
    fi
    if ! curl -L -C - --fail --retry 5 --no-progress-meter "$SOURCE_IMAGE" | tee >($DECOMPRESSOR | dd of="$TARGET_DEVICE" status=progress conv=fsync oflag=direct) | sha256sum > /run/rdi-installer/downloaded.sha256; then
	echo "Error: Downloading and write to device failed with exit code $?"
	$KEYWAIT -s 0
    fi
    EXPECTED_HASH=$(awk '{print $1}'  /run/rdi-installer/image.sha256)
    ACTUAL_HASH=$(awk '{print $1}'  /run/rdi-installer/downloaded.sha256)
    if [ "$EXPECTED_HASH" != "$ACTUAL_HASH" ]; then
	gum style --foreground="$COLOR_WARNING" "ERROR: SHA256 verification failed! Wiping invalid data and aborting..."
	sgdisk --zap-all "$TARGET_DEVICE"
	$KEYWAIT -s 0
	exit 1
    fi
else
    if [[ "$SOURCE_IMAGE" == /* ]]; then
	echo "Absolute Path Detected: $SOURCE_IMAGE"
	IMAGE_TO_WRITE="$SOURCE_IMAGE"
    elif [[ "$SOURCE_IMAGE" =~ (.*)\((/dev/.*)\)$ ]]; then
        # Extract the parts using BASH_REMATCH array
        prefix="${BASH_REMATCH[1]}"
        device="${BASH_REMATCH[2]}"

        # Verify if the extracted path is actually a block device
        if [ -b "$device" ]; then
            # Trim trailing space from prefix if present
            prefix="${prefix%"${prefix##*[![:space:]]}"}"

	    mount -r "$device" "${TEMP_DIR}/mount"
	    IMAGE_TO_WRITE="${TEMP_DIR}/mount/${prefix}"
        else
            echo "Error: Argument '$SOURCE_IMAGE' matches format, but '$device' is not a valid block device." >&2
	    exit 2 # XXX
        fi
    else
	echo "INTERNAL ERROR: $SOURCE_IMAGE"
	exit 3 # XXX
    fi

    if [ -n "$RDII_DEBUG" ]; then
	# shellcheck disable=SC2086
	gum spin $SPINNER --title.foreground="$COLOR_TITLE" --title="NOTHING WILL HAPPEN - Press any key to continue or wait 10s..." -- $KEYWAIT -t "" -s 10
    else
	# Verify Image!
	if [ ! -f "${IMAGE_TO_WRITE}.sha256" ]; then
	    if gum confirm \
		   --default \
		   --prompt.foreground "$COLOR_WARNING" \
		   --selected.background "$COLOR_WARNING" \
		   --selected.foreground "$COLOR_GRAY" \
		   --unselected.background "$COLOR_BACKGROUND" \
		   --unselected.foreground "$COLOR_GRAY" \
		   "No sha256 checksum found, really continue without image verification?"; then
		gum style --foreground "$COLOR_TEXT" "Confirmed. Proceeding..."
	    else
		gum style --foreground "$COLOR_TEXT" "Aborted."
		$KEYWAIT -t "" -s 2
		exit 1;
	    fi
	elif [ ! -f "${IMAGE_TO_WRITE}.sha256.asc" ]; then
	    if gum confirm \
		   --default \
		   --prompt.foreground "$COLOR_WARNING" \
		   --selected.background "$COLOR_WARNING" \
		   --selected.foreground "$COLOR_GRAY" \
		   --unselected.background "$COLOR_BACKGROUND" \
		   --unselected.foreground "$COLOR_GRAY" \
		   "No gpg signature found, really continue without verification?"; then
		gum style --foreground "$COLOR_TEXT" "Confirmed. Proceeding..."
	    else
		gum style --foreground "$COLOR_TEXT" "Aborted."
		$KEYWAIT -t "" -s 2
		exit 1;
	    fi
	elif ! gpgv --keyring /etc/systemd/import-pubring.gpg "${IMAGE_TO_WRITE}.sha256.asc" "${IMAGE_TO_WRITE}.sha256"; then
	    gum style --foreground="$COLOR_WARNING" "ERROR: GPG signature verification failed! Aborting..."
	    $KEYWAIT -s 0
	    exit 1
	fi

	if [ -f "${IMAGE_TO_WRITE}.sha256" ]; then
	    gum style --foreground="$COLOR_TEXT" "Verifying image..."
	    IMAGE_DIR=$(dirname "${IMAGE_TO_WRITE}.sha256")
	    pushd "$IMAGE_DIR" > /dev/null || exit 1
	    IMAGE_NAME=$(basename "${IMAGE_TO_WRITE}.sha256")
	    sha256sum -c "$IMAGE_NAME"
	    popd > /dev/null || exit 1
	    $KEYWAIT -s 2
	fi

	# Write the image
	if ! pv "$IMAGE_TO_WRITE" | $DECOMPRESSOR | dd of="$TARGET_DEVICE" bs=4M conv=fsync oflag=direct ; then
	    gum style --foreground="$COLOR_WARNING" "Failure writing the image"
	    $KEYWAIT -s 0
	else
	    gum style --foreground="$COLOR_TEXT" "Image successfully written"
	    $KEYWAIT
	fi
    fi
    mountpoint -q "${TEMP_DIR}/mount" && umount "${TEMP_DIR}/mount"
fi

clear_and_print_title
ACTION=$(gum choose \
	     --cursor="${CURSOR} " \
	     --cursor.foreground="$COLOR_FOREGROUND" \
	     --item.foreground="$COLOR_ITEM" \
	     --selected.foreground="$COLOR_FOREGROUND" \
	     --limit=1 \
	     "Reboot" "Next Image" "PowerOff" "Exit")
case $ACTION in
    Reboot)
	reboot
	;;
    PowerOff)
	poweroff
	;;
    Exit)
	exit 0
	;;
    *)
	exec rdi-installer
	;;
esac
